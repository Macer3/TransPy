# -*- coding: utf-8 -*-"""@author: Zhanhong Cheng"""from transpy.compute.heap import FastUpdateBinaryHeapimport numpy as npcimport numpy as npcimport cythonfrom transpy.compute.heap cimport FastUpdateBinaryHeapDTYPE = np.float64ctypedef np.float64_t DTYPE_tITYPE = np.int32ctypedef np.int32_t ITYPE_tUTYPE16 = np.uint16ctypedef np.uint16_t UTYPE16_tUTYPE8 = np.uint8ctypedef np.uint8_t UTYPE8_t    # BinaryHeap Cython@cython.boundscheck(False)def _turn_dijikstra(np.ndarray[UTYPE16_t, ndim=1] idx,                     np.ndarray[UTYPE16_t, ndim=1] ID,                     np.ndarray[UTYPE16_t, ndim=1] start_node,                     np.ndarray[UTYPE16_t, ndim=1] end_node,                     np.ndarray[DTYPE_t, ndim=1] weight,                     np.ndarray[UTYPE8_t, ndim=1] flag,                     UTYPE16_t source,                     UTYPE16_t target,                     np.ndarray[UTYPE16_t,ndim=1] turn_idx,                     np.ndarray[UTYPE16_t,ndim=1] _from,                     np.ndarray[UTYPE16_t,ndim=1] _to,                     np.ndarray[DTYPE_t,ndim=1] delay,                     np.ndarray[DTYPE_t, ndim=1] dist_matrix,                     np.ndarray[UTYPE16_t, ndim=2] pred):    """    Parameters    ----------    idx :    ID :    start_node :    end_node :    weight :    flag :    source :    target :     turn_idx :    _from :    _to :    delay :    dist_matrix :    pred :    Returns    -------    """    cdef DTYPE_t n_dist, c_dist = 0    cdef UTYPE16_t c_node, n_node, i, start_i, end_i, c_link, n_link, line    cdef UTYPE8_t c_flag    cdef FastUpdateBinaryHeap costs_heap = FastUpdateBinaryHeap(initial_capacity=128,                                            max_reference=dist_matrix.shape[0])    pred[0, source] = source  #todo 如何判断其实点是错误的，不存在的    dist_matrix[source] = 0    costs_heap.push_fast(0, source)        while costs_heap.count != 0:        c_dist = costs_heap.pop_fast()        c_node = costs_heap._popped_ref        if c_node == target:            return c_node        line = pred[1, c_node]  # current link line_num        c_flag = flag[line]        start_i = idx[c_node - 1]        end_i = idx[c_node]        if c_flag:            c_link = ID[line]            print('c_link is {}'.format(c_link))            line = turn_idx[c_node] -c_flag # corresponding delay line_num            print('line is {}'.format(line))            for i in range(start_i, end_i):                n_node = end_node[i]                n_link = ID[i]                if _from[line] != c_link:                    n_dist = c_dist + weight[i]                elif _to[line] != n_link:                    n_dist = c_dist + weight[i]                else:                    n_dist = c_dist + weight[i] + delay[line]                    line += 1                if n_dist < dist_matrix[n_node]:                    pred[0, n_node] = c_node                    pred[1, n_node] = i                    dist_matrix[n_node] = n_dist                    costs_heap.push_if_lower_fast(n_dist, n_node)        else:            for i in range(start_i, end_i):                n_node = end_node[i]                n_dist = c_dist + weight[i]                        if n_dist < dist_matrix[n_node]:                    pred[0, n_node] = c_node                    pred[1, n_node] = i                    dist_matrix[n_node] = n_dist                    costs_heap.push_if_lower_fast(n_dist, n_node)    return c_node